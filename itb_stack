#! /usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright (c) 2025 Mikio Hirabayashi
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import argparse
import logging
import os
import subprocess
import sys

import cv2
import numpy as np


PROG_NAME = "itb_combine"
PROG_VERSION = "0.0.1"
CMD_EXIFTOOL = "exiftool"


logging.basicConfig(format="%(message)s", stream=sys.stderr)
logger = logging.getLogger(PROG_NAME)
logger.setLevel(logging.INFO)
cmd_env = os.environ.copy()
cmd_env["PATH"] = cmd_env["PATH"] + ":/usr/local/bin"
cmd_env["PATH"] = cmd_env["PATH"] + ":/Applications/Hugin/tools_mac"
cv2.setLogLevel(0)


def load_image(file_path):
  """Load an image and return its linear RGB data as a NumPy array."""
  np_img = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
  if np_img is None:
    raise ValueError(f"Failed to load {file_path}")
  if np_img.dtype == np.uint32:
    np_img = np_img.astype(np.float32) / float((1<<32) - 1)
    bits = 32
  elif np_img.dtype == np.uint16:
    np_img = np_img.astype(np.float32) / float((1<<16) - 1)
    bits = 16
  else:
    np_img = np_img.astype(np.float32) / float((1<<8) - 1)
    bits = 8
  if len(np_img.shape) == 2:
    np_img = cv2.cvtColor(np_img, cv2.COLOR_GRAY2BGR)
  elif np_img.shape[2] == 4:
    np_img = cv2.cvtColor(np_img, cv2.COLOR_BGRA2BGR)
  np_img = srgb_to_linear(np_img)
  return np_img, bits


def save_image(file_path, np_img, bits, icc_profile=None, exif_data=None):
  """Save an image after converting it from linear RGB to sRGB while preserving metadata."""
  np_img = linear_to_srgb(np_img)
  ext = file_path.split('.')[-1].lower()
  if ext in ['jpg', 'jpeg']:
    np_img = (np.clip(np_img, 0, 1) * ((1<<8) - 1)).astype(np.uint8)
  elif ext in ['png', 'tiff', 'tif']:
    if bits == 32:
      np_img = (np.clip(np_img, 0, 1) * ((1<<32) - 1)).astype(np.uint32)
    elif bits == 16:
      np_img = (np.clip(np_img, 0, 1) * ((1<<16) - 1)).astype(np.uint16)
    else:
      np_img = (np.clip(np_img, 0, 1) * ((1<<8) - 1)).astype(np.uint8)
  else:
    raise ValueError(f"Unsupported file format: {ext}")
  success = cv2.imwrite(file_path, np_img)
  if not success:
    raise ValueError(f"Failed to save image: {file_path}")


def copy_metadata(source_path, target_path):
  """Copy EXIF data and ICC profile from source image to target image."""
  cmd = ["exiftool", "-TagsFromFile", source_path, "-icc_profile",
         "-thumbnailimage=", "-f", "-m", "-overwrite_original", target_path]
  subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def srgb_to_linear(image):
  """Convert sRGB to linear RGB using OpenCV (optimized for float32)."""
  mod_image = np.where(image <= 0.04045, image / 12.92, cv2.pow((image + 0.055) / 1.055, 2.4))
  return mod_image


def linear_to_srgb(image):
  """Convert linear RGB to sRGB using OpenCV (optimized for float32)."""
  mod_image = np.where(image <= 0.0031308, image * 12.92, 1.055 * cv2.pow(image, 1/2.4) - 0.055)
  return mod_image


def compute_brightness(image):
  """Compute the average brightness of an image in grayscale."""
  return np.mean(cv2.cvtColor(image.astype(np.float32), cv2.COLOR_BGR2GRAY))


def lighten_image(image, factor):
  """Lightens the image by applying a scaled log transformation."""
  return np.log1p(image * factor) / np.log1p(factor)


def darken_image(image, factor):
  """Darkens the image by applying an inverse log transformation."""
  return (np.expm1(image * np.log1p(factor))) / factor


def naive_sigmoid(x, gain, mid):
  """Computes naive sigmod conversion."""
  return 1.0 / (1.0 + np.exp((mid - x) * gain))


def naive_inverse_sigmoid(x, gain, mid):
  """Computes inverse naive sigmoid conversion."""
  min_val = naive_sigmoid(0.0, gain, mid)
  max_val = naive_sigmoid(1.0, gain, mid)
  a = (max_val - min_val) * x + min_val
  return -np.log(1.0 / a - 1.0) / gain


def sigmoidal_contrast(image, gain, mid):
  """Apply sigmoidal contrast adjustment with a scaled sigmoid function."""
  min_val = naive_sigmoid(0.0, gain, mid)
  max_val = naive_sigmoid(1.0, gain, mid)
  diff = max_val - min_val
  return np.clip((naive_sigmoid(image, gain, mid) - min_val) / diff, 0, 1)


def inverse_sigmoidal_contrast(image, gain, mid):
  """Apply inverse sigmoidal contrast adjustment."""
  min_val = naive_inverse_sigmoid(0.0, gain, mid)
  max_val = naive_inverse_sigmoid(1.0, gain, mid)
  diff = max_val - min_val
  return np.clip((naive_inverse_sigmoid(image, gain, mid) - min_val) / diff, 0, 1)


def adjust_exposure(images):
  """
  Adjusts the exposure of multiple images to match their brightness in log space.
  Returns a list of adjusted images.
  """
  brightness_values = np.array([compute_brightness(img) for img in images])
  mean_brightness = np.mean(brightness_values)
  adjusted_images = []
  for img, brightness in zip(images, brightness_values):
    tries = 0
    leverage = 1.0
    while tries < 10:
      tries += 1
      if brightness == 0 or mean_brightness == 0 or brightness == mean_brightness:
        break
      dist = abs(np.log(mean_brightness / brightness))
      if dist < 0.1:
        break
      if brightness <= mean_brightness:
        factor = np.expm1(mean_brightness * np.log1p(brightness)) / brightness
        factor += leverage
        adjusted_img = lighten_image(img, factor)
      else:
        factor = np.expm1(np.log1p(mean_brightness) / brightness)
        factor += leverage
        adjusted_img = darken_image(img, factor)
      adjusted_brightness = compute_brightness(adjusted_img)
      adjusted_dist = abs(np.log(mean_brightness / adjusted_brightness))
      if adjusted_dist < dist:
        img = adjusted_img
        brightness = adjusted_brightness
      leverage *= 0.5
    adjusted_images.append(img)
  return adjusted_images


def merge_images(images):
  """Merge images by averaging pixel values."""
  return np.mean(images, axis=0)


def main():
  description = """Stack and combine images.
"""
  epilog = "{prog} version {ver}. Powered by OpenCV2.".format(
    prog=PROG_NAME, ver=PROG_VERSION)
  ap = argparse.ArgumentParser(
    prog=PROG_NAME, description=description, epilog=epilog,
    formatter_class=argparse.RawDescriptionHelpFormatter)
  ap.add_argument("images", nargs='+', help="input image paths")
  ap.add_argument("--output", "-o", default="output.tif", metavar="path",
                  help="output image path (dafault=output.tif)")
  ap.add_argument("--adjust-exposure", "-ax", action='store_true', help="adjust exposure automatically")
  ap.add_argument("--slog", type=float, default=0, metavar="num",
            help="scaled log brightness adjustment. positive to lighten, negative to darken")
  ap.add_argument("--sigmoid", type=float, default=0, metavar="num",
            help="sigmoidal contrast adjustment. positive to strengthen, negative to weaken")
  args = ap.parse_args()
  images_data = [load_image(img) for img in args.images]
  images, bits_list = zip(*images_data)
  if args.adjust_exposure:
    images = adjust_exposure(images)
  merged_image = merge_images(images)
  if args.slog > 0:
    merged_image = lighten_image(merged_image, args.slog)
  elif args.slog < 0:
    merged_image = darken_image(merged_image, -args.slog)
  if args.sigmoid > 0:
    merged_image = sigmoidal_contrast(merged_image, args.sigmoid, 0.5)
  elif args.sigmoid < 0:
    merged_image = inverse_sigmoidal_contrast(merged_image, -args.sigmoid, 0.5)
  save_image(args.output, merged_image, bits_list[0])
  copy_metadata(args.images[0], args.output)
  print(f"Saved merged image as {args.output}")


if __name__ == "__main__":
  main()
